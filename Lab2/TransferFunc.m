function [H, stdH] = TransferFunc(umat, ymat, AvgArry, HFuntion)% Computes the estimate of the transfer function, according to the code% defined in Hfunction (which you need to create). A for loop is performed, for each element of the% vector 'AvgArry'. %%%%% Example.    %%% Calling of the function: [H, stdH] = TransferFunc(xmat,ymat,[2,4,8,16,32],@FD_avg);    %%% Let's assume that the measurement has 32 repetitions, each with N    %%% samples, and that @FD_avg is a function that computed frequency    %%% domain averaging.     %%% In the first iteration of the 'for loop', the averaging is performed using 2 repetitions, and it will be performed 32/2=16 times.     %%% The results are stored into AllH, of size [Nx16].     %%% The standard deviation between the 16 estimates is saved in the first column of 'stdH'.     %%% To make the results more readable, only the first column of AllH is saved into H.     %%% The for loop is repeated 5 times, so stdH and H will have N rows and 5  columns. if size(umat) ~= size(ymat)	error('Input and output measurements must have the same size.');end% Obtain parameters and initialize matrices[TimeSamples, Experiments] = size(umat);LengthAvgArry = length(AvgArry);H = zeros(TimeSamples, LengthAvgArry);stdH = zeros(TimeSamples, LengthAvgArry);% For loop, for each value of AvgArrayfor AvgIndx = 1:LengthAvgArry    	Averages = AvgArry(AvgIndx); 		NrH = fix(Experiments/Averages);	AllH = zeros(TimeSamples, NrH);	for indx = 1:NrH		SelectExp = (indx-1)*Averages+[1:Averages];		AllH(:, indx) = feval(HFuntion, umat(:,SelectExp), ymat(:,SelectExp));    end		H(:, AvgIndx) = AllH(:, 1);	if NrH > 1		stdH(:, AvgIndx) = std(AllH.').';	else		stdH(:, AvgIndx) = NaN*ones(TimeSamples, 1);    endend